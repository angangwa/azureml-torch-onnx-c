"""
Script for converting ONNX model to C code using onnx2c.
This will run inside the AML pipeline.
"""
import os
import argparse
import subprocess
import glob
import shutil

def main():
    # Parse arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("--model_dir", type=str, help="Directory containing ONNX model")
    parser.add_argument("--output_dir", type=str, help="Output directory for C code")
    args = parser.parse_args()
    
    print("Starting ONNX to C conversion process...")
    
    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Find ONNX model file
    onnx_files = glob.glob(os.path.join(args.model_dir, "*.onnx"))
    if not onnx_files:
        raise FileNotFoundError(f"No ONNX model found in {args.model_dir}")
    
    onnx_model_path = onnx_files[0]
    print(f"Found ONNX model: {onnx_model_path}")
    
    # Output C file path
    c_output_path = os.path.join(args.output_dir, "time_series_model.c")
    
    # Convert ONNX to C using onnx2c
    print(f"Converting ONNX model to C code...")
    
    result = subprocess.run(
        ["onnx2c", onnx_model_path],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        raise RuntimeError(f"onnx2c failed with error: {result.stderr}")
    
    # Save the C code to file
    with open(c_output_path, "w") as f:
        f.write(result.stdout)
    
    print(f"C code saved to {c_output_path}")
    
    # Copy model_impl.c, test_model.c, and time_series_model.h files
    # These are the files you provided that don't change
    
    # Write additional files needed for compilation and testing
    model_impl_content = """#include "time_series_model.h"

/* 
 * This is the entry point function generated by onnx2c.
 * It expects input as a 2D array [1][1] and outputs to a 2D array [1][1].
 */
extern void entry(const float input[1][1], float output[1][1]);

void time_series_model_init(void) {
    /* No initialization needed for this model */
}

void time_series_model_run(const float* input_data, float* output_data) {
    /* 
     * The entry function expects 2D arrays, but our API uses simple pointers.
     * We need to reshape the data accordingly.
     */
    float input_reshaped[1][1] = {{*input_data}};  /* Convert single value to 2D array */
    float output_reshaped[1][1];
    
    /* Call the generated model function */
    entry(input_reshaped, output_reshaped);
    
    /* Copy the result back to the output pointer */
    *output_data = output_reshaped[0][0];
}

void time_series_model_terminate(void) {
    /* No cleanup needed for this model */
}"""

    test_model_content = """#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "time_series_model.h"

// Function to read CSV file containing float values
float* read_csv(const char* filename, int* size) {
    // Add debug message to see what's happening
    printf("Attempting to open file: %s\\n", filename);
    
    FILE* file = fopen(filename, "r");
    if (!file) {
        printf("Error: Could not open file %s\\n", filename);
        return NULL;
    }
    
    printf("Successfully opened file\\n");
    
    // Count lines first to allocate proper memory
    int count = 0;
    char buffer[100];
    
    // More reliable way to count lines
    while (fgets(buffer, sizeof(buffer), file)) {
        count++;
    }
    
    printf("Found %d lines in file\\n", count);
    
    // Reset file position
    rewind(file);
    
    // Allocate memory
    float* data = (float*)malloc(count * sizeof(float));
    if (!data) {
        printf("Error: Memory allocation failed\\n");
        fclose(file);
        return NULL;
    }
    
    // Read data
    int i = 0;
    while (fgets(buffer, sizeof(buffer), file) && i < count) {
        // Convert string to float
        data[i++] = atof(buffer);
    }
    
    fclose(file);
    *size = count;
    
    printf("Successfully loaded %d values\\n", count);
    return data;
}

int main() {
    printf("Testing the time series neural network model\\n");
    
    // Try current directory first (instead of parent directory)
    int input_size = 0, output_size = 0;
    float* test_inputs = read_csv("test_input.csv", &input_size);
    
    // If that fails, try the parent directory
    if (!test_inputs) {
        printf("Trying parent directory...\\n");
        test_inputs = read_csv("../test_input.csv", &input_size);
    }
    
    float* expected_outputs = NULL;
    if (test_inputs) {
        // Use the same directory that worked for inputs
        if (input_size > 0) {
            expected_outputs = read_csv("expected_output.csv", &output_size);
            if (!expected_outputs) {
                expected_outputs = read_csv("../expected_output.csv", &output_size);
            }
        }
    }
    
    if (!test_inputs || !expected_outputs) {
        printf("Failed to read test data\\n");
        return 1;
    }
    
    if (input_size != output_size) {
        printf("Error: Input and output size mismatch (%d vs %d)\\n", 
               input_size, output_size);
        free(test_inputs);
        free(expected_outputs);
        return 1;
    }
    
    printf("Successfully loaded %d test samples\\n", input_size);
    
    // Initialize the model
    time_series_model_init();
    
    // Test model with each input
    float total_error = 0.0f;
    int display_count = input_size < 5 ? input_size : 5;
    
    printf("\\nDisplaying first %d results:\\n", display_count);
    printf("--------------------------------------------------\\n");
    printf("   Input   |   Expected   |   Predicted   | Error  \\n");
    printf("--------------------------------------------------\\n");
    
    for (int i = 0; i < input_size; i++) {
        float input = test_inputs[i];
        float expected = expected_outputs[i];
        float output = 0.0f;
        
        // Run model inference
        time_series_model_run(&input, &output);
        
        // Calculate error
        float error = fabs(output - expected);
        total_error += error;
        
        // Print first few results
        if (i < display_count) {
            printf("%10.4f | %12.4f | %13.4f | %6.4f\\n", 
                   input, expected, output, error);
        }
    }
    
    // Print summary
    float avg_error = total_error / input_size;
    printf("--------------------------------------------------\\n");
    printf("Average prediction error: %f\\n", avg_error);

    // Write results to output file
    FILE* result_file = fopen("test_results.txt", "w");
    if (result_file) {
        fprintf(result_file, "Average prediction error: %f\\n", avg_error);
        fclose(result_file);
    }
    
    // Clean up
    time_series_model_terminate();
    free(test_inputs);
    free(expected_outputs);
    
    printf("\\nTest completed successfully!\\n");
    return 0;
}"""

    header_content = """#ifndef TIME_SERIES_MODEL_H
#define TIME_SERIES_MODEL_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Initialize the model (if needed)
 * For this simple model, this is a no-op, but included for API completeness
 */
void time_series_model_init(void);

/**
 * Run inference with the neural network model
 * 
 * @param input_data Pointer to a single float value (the time input)
 * @param output_data Pointer to a float where the prediction will be stored
 */
void time_series_model_run(const float* input_data, float* output_data);

/**
 * Clean up any resources used by the model (if needed)
 * For this simple model, this is a no-op, but included for API completeness
 */
void time_series_model_terminate(void);

#ifdef __cplusplus
}
#endif

#endif /* TIME_SERIES_MODEL_H */"""

    minimal_wrapper_content = """#ifndef NN_WRAPPER_H
#define NN_WRAPPER_H

#ifdef __cplusplus
extern "C" {
#endif

// Forward declaration of the entry function from onnx2c output
extern void entry(const float input[1][1], float output[1][1]);

/**
 * Run the neural network inference
 * 
 * @param input_value Single input value
 * @param output_value Pointer to store the output
 */
static inline void nn_run(float input_value, float* output_value) {
    float input_array[1][1] = {{input_value}};
    float output_array[1][1];
    
    // Call the entry function from the onnx2c generated code
    entry(input_array, output_array);
    
    // Copy output
    *output_value = output_array[0][0];
}

#ifdef __cplusplus
}
#endif

#endif /* NN_WRAPPER_H */"""

    minimal_example_content = """#include "nn_wrapper.h"

/**
 * Minimal example of using the neural network
 * This represents the code that would run on the microcontroller
 */
int main(void) {
    // Example input value (would come from sensors in real deployment)
    float input_value = 42.0f;
    float prediction = 0.0f;
    
    // Run neural network inference
    nn_run(input_value, &prediction);
    
    // On a microcontroller, you would use the prediction here
    // e.g., control an actuator, make a decision, etc.
    
    return 0;
}"""

    compile_script_content = """#!/bin/bash

echo "Compiling minimal neural network implementation using original onnx2c output..."

# Compile with size optimization
gcc -Os -fdata-sections -ffunction-sections -Wl,--gc-sections \\
    minimal_example.c time_series_model.c -o minimal_nn -lm

# Check if compilation succeeded
if [ $? -eq 0 ]; then
    echo "Compilation successful!"
    
    # Create stripped version
    cp minimal_nn minimal_nn_stripped
    strip minimal_nn_stripped
    
    # Show the size of both binaries
    echo -e "\\nBinary size information:"
    ls -lh minimal_nn | awk '{print "Normal size: " $5}'
    ls -lh minimal_nn_stripped | awk '{print "Stripped size: " $5}'
    
    # Show detailed size breakdown
    echo -e "\\nDetailed size breakdown:"
    size minimal_nn
    
    echo -e "\\nStripped binary size breakdown:"
    size minimal_nn_stripped
    
    # Show sections size
    echo -e "\\nSection size details:"
    objdump -h minimal_nn_stripped | grep -E '\\.text|\\.data|\\.bss|\\.rodata'
    
    # Estimate microcontroller ROM/RAM usage
    TEXT_SIZE=$(objdump -h minimal_nn_stripped | grep "\\\.text" | awk '{print $3}')
    RODATA_SIZE=$(objdump -h minimal_nn_stripped | grep "\\\.rodata" | awk '{print $3}')
    DATA_SIZE=$(objdump -h minimal_nn_stripped | grep "\\\.data" | awk '{print $3}')
    BSS_SIZE=$(objdump -h minimal_nn_stripped | grep "\\\.bss" | awk '{print $3}')
    
    # Convert hex to decimal
    TEXT_DEC=$((16#$TEXT_SIZE))
    RODATA_DEC=$((16#${RODATA_SIZE:-0}))
    DATA_DEC=$((16#${DATA_SIZE:-0}))
    BSS_DEC=$((16#${BSS_SIZE:-0}))
    
    echo -e "\\nEstimated microcontroller memory usage:"
    echo "ROM (Flash) usage: ~$((TEXT_DEC + RODATA_DEC + DATA_DEC)) bytes"
    echo "RAM usage: ~$((DATA_DEC + BSS_DEC)) bytes"
    
    echo -e "\\nNote: This is the minimal size using the original onnx2c output."
    echo "For actual microcontroller deployment, you may need additional platform-specific code."
else
    echo "Compilation failed!"
fi"""

    with open(os.path.join(args.output_dir, "model_impl.c"), "w") as f:
        f.write(model_impl_content)
        
    with open(os.path.join(args.output_dir, "test_model.c"), "w") as f:
        f.write(test_model_content)
        
    with open(os.path.join(args.output_dir, "time_series_model.h"), "w") as f:
        f.write(header_content)
        
    with open(os.path.join(args.output_dir, "nn_wrapper.h"), "w") as f:
        f.write(minimal_wrapper_content)
        
    with open(os.path.join(args.output_dir, "minimal_example.c"), "w") as f:
        f.write(minimal_example_content)
        
    with open(os.path.join(args.output_dir, "compile_minimal.sh"), "w") as f:
        f.write(compile_script_content)
    
    # Make compile script executable
    os.chmod(os.path.join(args.output_dir, "compile_minimal.sh"), 0o755)
    
    # Copy test data
    for csv_file in ["test_input.csv", "expected_output.csv"]:
        csv_path = os.path.join(args.model_dir, csv_file)
        if os.path.exists(csv_path):
            shutil.copy(csv_path, args.output_dir)
            print(f"Copied {csv_file} to output directory")
    
    print("ONNX to C conversion completed successfully")

if __name__ == "__main__":
    main()